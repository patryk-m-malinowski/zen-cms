/* ************************************************************************
 *
 *  Zen [and the art of] CMS
 *
 *  https://zenesis.com
 *
 *  Copyright:
 *    2019-2022 Zenesis Ltd, https://www.zenesis.com
 *
 *  License:
 *    MIT (see LICENSE in project root)
 *
 *  Authors:
 *    John Spackman (john.spackman@zenesis.com, @johnspackman)
 *
 * ************************************************************************ */

/**
 * @use(zx.app.pages.LiveEditProxy)
 * @use(zx.app.pages.RemoteControlProxy)
 * @use(zx.cms.content.ContainerPieceRemoteControl)
 * @use(zx.cms.content.ContentPieceRemoteControl)
 * @use(zx.cms.content.PageRemoteControl)
 * @use(zx.server.CmsConfiguration)
 * @use(zx.thin.core.FeatureClientInstaller)
 * @use(zx.thin.app.login.LoginFormControllerInstaller)
 *
 * @asset(qx/iconfont/MaterialIcons/*)
 * @asset(zx/cms/fontawesome/*)
 */
qx.Class.define("zx.thin.ThinClientApp", {
  extend: qx.application.Native,

  construct() {
    super();
    this.__readyPromise = new qx.Promise();

    let dom = qx.bom.Selector.query("#qx-thin-client-root")[0];
    if (dom) {
      this.__root = new qx.html.Root(dom);
    } else {
      let elem = document.createElement("div");
      this.__root = new qx.html.Root(elem);
      qx.html.Element.setDefaultRoot(this.__root);
      document.body.append(elem);
    }
    this.__editablePieces = {};

    if (qx.core.Environment.get("qx.debug")) {
      // support native logging capabilities, e.g. Firebug for Firefox
      qx.log.appender.Native;
      // support additional cross-browser console. Press F7 to toggle visibility
      qx.log.appender.Console;
    }
  },

  properties: {
    /** Whether to start the network I/O server for talking to this app as an iframe inside another Zx app */
    enableIframeServer: {
      init: false,
      check: "Boolean"
    }
  },

  members: {
    /** @type {qx.html.Root} the root window element */
    __root: null,

    /** @type {zx.io.remote.NetworkController} the network controller for talking to windows, ie the parent window */
    __outerFrameController: null,

    /** @type {zx.io.remote.NetworkController} the network controller for talking to the server */
    __networkController: null,

    /** @type {Boolean} true when the endpoint has opened successfully */
    __endpointOpen: false,

    /** @type {zx.app.pages.LiveEditProxy} the proxy, if provided by the parent window */
    __liveEditProxy: null,

    /** @type {qx.util.DynamicScriptLoader} the loader for additional scripts, eg the content editable editor */
    __scriptLoader: null,

    /** @type {Boolean} true when the scripts have finished loading */
    __scriptsLoaded: false,

    /** @type {Promise} resolves when the application has finished initialising */
    __readyPromise: null,

    /**
     * @typedef {Object} EditablePiece
     * @property {String} uuid the UUID of the piece
     * @property {String} classname the classname of the remote control for the piece
     * @property {Element[]} elements an array of elements that form this piece
     * @property {zx.cms.content.AbstractRemoteControl} remoteControl the remote control instance
     *
     * @type{Map<String,EditablePiece} list of editable pieces, indexed by uuid
     */
    __editablePieces: null,

    /**
     * @Override
     */
    async main() {
      await super.main();

      if (this.isEnableIframeServer() && window !== window.parent) {
        // Controller manages the objects and their serialisation
        let ctlr = (this.__outerFrameController = new zx.io.remote.NetworkController());
        ctlr.addListener("uriMapping", evt => {
          let { uri, object } = evt.getData();
          if (uri == "zx.app.pages.PageEditor.liveEditProxy") {
            this.__liveEditProxy = object;
            this.__checkScripts();
          }
        });

        // Connect to the parent window because we know that we are in an iframe created by PeerOne
        let endpoint = new zx.io.remote.WindowEndpoint(window.parent);
        ctlr.addEndpoint(endpoint);
        await endpoint.open();
        this.__endpointOpen = true;

        ctlr.putUriMapping("zx.thin.ThinClientApp.remoteControlProxy", new zx.app.pages.RemoteControlProxy());
      }

      this.__readyPromise.resolve();
    },

    /**
     * Waits for the application to become ready
     *
     * @returns
     */
    async waitForReady() {
      return await this.__readyPromise;
    },

    /**
     * Called by the code in the HTML, which was generated by the piece, to connect DOM Element's to an editor
     *
     * @param {String} uuid UUID of the piece
     * @param {String} classname class name of the remote control
     * @param {Element|Element[]|String?} elements list of filter for the UUID, if not provided then the UUID is used to locate them
     */
    addEditablePiece(uuid, classname, filter) {
      let elements = null;
      if (uuid) {
        elements = qx.lang.Array.fromCollection(document.querySelectorAll('[data-zx-cms-piece-uuid="' + uuid + '"]'));
        if (typeof filter == "string") {
          let tmp = [];
          elements.forEach(target => {
            let found = qx.bom.Selector.query(filter, target);
            qx.lang.Array.append(tmp, found);
          });
          elements = tmp;
        }
      } else if (typeof filter == "string") {
        elements = qx.bom.Selector.query(filter);
      } else if (qx.lang.Type.isArray(filter)) {
        elements = filter;
      } else {
        elements = [filter];
      }

      let data = (this.__editablePieces[uuid] = {
        uuid,
        classname,
        elements,
        remoteControl: null
      });

      this.__checkScripts();
    },

    /**
     * @param {Element} div the div to start searching from
     * @returns {EditablePiece}
     */
    findEditablePiece(div) {
      let editable = null;
      for (var tmp = div; tmp != null; tmp = tmp.parentElement) {
        let uuid = div.getAttribute("data-zx-cms-piece-uuid");
        if (uuid) {
          editable = this.__editablePieces[uuid];
          if (!editable) {
            throw new Error(`Found piece with UUID ${uuid} but it is not editable`);
          }
          return editable;
        }
      }
      return null;
    },

    /**
     * Finds the remote control for a given piece, by uuid
     *
     * @param {String} uuid
     * @return {zx.cms.content.AbstractRemoteControl}
     */
    findRemoteControl(uuid) {
      let editable = this.__editablePieces[uuid];
      return (editable && editable.remoteControl) || null;
    },

    /**
     * Checks whether additional scripts are needed, and loads them if they are needed and have not yet been
     * loaded.  Safe to call multiple times.
     */
    __checkScripts() {
      if (this.__liveEditProxy && !this.__scriptLoader && Object.keys(this.__editablePieces).length) {
        this.__scriptLoader = new qx.util.DynamicScriptLoader("/zx/extra/medium-editor/js/medium-editor.min.js");
        qx.bom.Stylesheet.includeFile("/zx/extra/medium-editor/css/medium-editor.min.css");
        qx.bom.Stylesheet.includeFile("/zx/extra/medium-editor/css/themes/bootstrap.min.css");
        this.__scriptLoader.start().then(() => this.__onScriptsLoaded());
      }
    },

    /**
     * Called when all scripts are loaded
     */
    __onScriptsLoaded() {
      this.__scriptsLoaded = true;
      Object.values(this.__editablePieces).forEach(editable => {
        if (!editable.remoteControl) {
          let clazz = qx.Class.getByName(editable.classname);
          if (!clazz) {
            throw new Error(`Cannot create remote control class ${editable.classname} because it does not exist`);
          }
          editable.remoteControl = new clazz(editable.uuid, editable.elements);
          editable.remoteControl.initialise();
        }
      });
    },

    /**
     * The network controller for talking to windows, ie the parent window
     *
     * @returns {zx.io.remote.NetworkController}
     */
    getOuterFrameController() {
      return this.__outerFrameController;
    },

    /**
     * The network controller for talking to the server
     */
    async getNetController() {
      if (this.__netController) {
        return this.__netController;
      }

      // Controller manages the objects and their serialisation
      this.__netController = new zx.io.remote.NetworkController();

      // Connect to the parent window because we know that we are in an iframe created by PeerOne
      let endpoint = (this.__endpoint = new zx.io.remote.BrowserXhrEndpoint().set({
        polling: false,
        shareConnection: false
      }));

      this.__netController.addEndpoint(endpoint);
      let promise = new qx.Promise();
      await endpoint.open().then(() => {
        // For transparent remote method calls
        zx.io.remote.NetworkEndpoint.setDefaultEndpoint(endpoint);
        promise.resolve();
      });
      await promise;
      return this.__netController;
    },

    closeNetController() {
      if (this.__netController) {
        this.__netController.close();
        this.__netController = null;
      }
    },

    /**
     * Gets a named API from the server
     *
     * @param {String} apiName
     * @returns {qx.core.Object}
     */
    async getApi(apiName) {
      let nc = await this.getNetController();
      let cmsConfig = await nc.getUriMappingAsync("zx.server.CmsConfiguration");
      let api = cmsConfig.getApi(apiName);
      return api;
    },

    /**
     * The root UI widget
     *
     * @returns {qx.html.Element}
     */
    getRoot() {
      return this.__root;
    }
  }
});
